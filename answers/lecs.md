## Лекция 2

##### Вопрос: что произойдёт при наличии рекурсивного типа?
Ответ: применён регулярный union-find-солвер унификации (`src/tip/solvers/UnionFindSolver.scala`), который допускает рекурсивные термы, а типы записываются через μ-нотацию. 
Пример (`examples/rectype.tip`):

```
main() {
    var p;
    p = alloc null;
    *p=p;
    return 0;
}
```

Типы, выведенные анализом:

```
⟦0[5:12]⟧ : int
⟦null[3:15]⟧ : ⭡x7
⟦main(){...}:1:1⟧ : () -> x5
⟦p[2:9]⟧ : ⭡μx6.⭡x6
⟦alloc null[3:9]⟧ : ⭡μx6.⭡x6
```

##### Вопрос: что меняется при добавлении Bool?
- В условных конструкциях и сравнениях требуем Bool у соответствующих выражений,
- Precision остаётся прежней (пропускаем только корректные программы),
- Recall падает: некоторые семантически корректные случаи не проходят типизацию (пример с if (x) при int x=1).

1. `E1 == E2` даёт `[[E1]] == [[E2]]` и `[[E1==E2]] == Bool`,

2. `if (E) ...` требует `[[E]] == Bool`,

3. `while (E) ...` требует `[[E]] == Bool`.

##### Вопрос: как ввести Array<α>?
Идея: массив с параметром типа α и согласованные правила индексации/литералов. Переставим пункты для краткости:
- Индексация: из `A[E]` следует `[[E]]==int`, `[[A]]==Array<α>`, а `[[A[E]]]==α`.
- Пустой литерал `{}` типизируем как `Array<α>`.
- Литерал `{X1,...,XN}` требует равенства всех `[[Xi]]` и даёт `Array<[[X1]]>`.
- Обращение вида `X[E1] op E2` навязывает `[[E1]]==int` и согласование типов результата. 

Пример:
```
main() {
    var x, y, z, t;
    x = {2, 4, 8, 16, 32, 64};    // Array<Int>
    y = x[x[3]];                  // Int
    z = {{}, x};                  // Array<Array<Int>>
    t = z[1];                     // Array<Int>
    t[2] = y;
}
```

## Лекция 3

##### Можно ли представить прежний типовой анализ как анализ над решётками?
Да: плоская решётка, где Top — типовая переменная, Bottom — ошибка типизации, а конкретные типы — промежуточные элементы. Для «более умной» решётки понадобилось бы отношение подтипизации, которого в языке (к моменту лекции 2) нет.
##### Можно ли выразить анализ над решетками как анализ типов?
Да, если ввести subtyping, `Top=Any/Object` и `Bottom=Nothing/Nil`. Не все языки так выразимы (напр., C++), но для Scala 3 существенная часть укладывается.

## Лекция 4

##### Какова сложность структурного алгоритма? (для liveness analysis)
(пусть `n` -- число узлов CFG, `k` -- количество переменных)
Структурный алгоритм:
- Изначально в очереди O(`n`) итераций за каждый узел CFG (точнее даже просто `n`)
- Проходим один узел CFG за итерацию
- Шаг `y = f_i (x1, x2, ..., xn)` (работа функции системы ограничений): O(`n*k`) шагов:
    - за `JOIN(n) ∪ vars(n)`
- После шага `WL ← WL ∪ deps(v_i)` потенциально число операций может увеличиться на O(`n`) максимум (если в языке есть pattern-matching, иначе вообще на O(1))

Итого O(`n*n*k`)

##### А если в CFG нет циклов?
Базовый анализ с предыдущего пункта никак не учитывал циклы, `JOIN` и `vars` не зависят от циклов, поэтому они не должны влиять на итоговый результат

##### Какова сложность по памяти?
На каждом конкретном шаге необходимо хранить состояние следующих O(`n`) узлов-последователей и O(`k`) переменных, итого O(`n`) + O(`k`)


## Лекция 5
Допустим, мы хотим реализовать оптимизирующий компилятор для языка TIP. Среди прочего, для работы ему требуется информация о размерах различных переменных.
- bool (1 bit)
- byte (8 bit signed)
- char (16 bit unsigned)
- int (32 bit signed)
- bigint (any integer)
- any (any thing)

`(T) E` — операция приведения типов

##### Предложите решетку для реализации анализа размера переменных
*Note: Нужно описать не только решетку для одного абстрактного значения, но и все другие решетки, требуемые для анализа целой программы*

Воспользуемся существующей решеткой для интервального анализа, но все интервалы будут представлять собой краевые значения типов, описанных в условии: [0, 1] для Bool, etc. Соответственно будет переиспользована и решетка из переменных в их интервалы. Для более удобного представления типов можно пост-обработать результаты функцией, переводящей конкретные значения в границах интервалов в биты размера.

##### Опишите правила вычисления различных выражений
Правила вычислений остаются такими же: `eval(σ, INT) = [INT, INT]`, etc., поскольку мы просто переиспользовали уже существующий анализ по-максимуму.

Если бы мы сделали решётку сразу по размеру числа, пришлось бы переделывать eval не тривиальным образом. Например, не совсем понятно, что делать со сложением двух интервалов: переходит ли правая граница получившегося интервала в следующий разряд или нет. Удобнее всего не работать с такой решеткой сразу, а пост-обрабатывать результат до битов.

##### Придумайте нетривиальный пример программы на TIP для получившегося анализа и посмотрите, что для него получается

```
main() {
    var x,y;
    x = 100;         // [100, 100]
    y = 10000;       // [10000, 10000]
    while (input) {
        x = 7;       // [7, 7]
        x = x+1;     // [8, 8]
        y = y+1;     // [128, +inf] (128 — макс. степень 2 < 10000)
    }
    if (y > 12000) y = 2;   // [2, 2]
    else y = y+1;           // [128, +inf]
    return y;               // [2, +inf]
}
```


## Лекция 6

##### Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат даже с учётом всех возможных условий в переходах
Чтобы испортить результаты анализа, достаточно добавить в исходную программу к переменной `flag` зависимость от какой-нибудь ещё переменной, например:

```
if (x > 15) {
  open();
  flag = 1;
  // Здесь всё как обычно
} else {
  close();
  if (x == 5) {
    flag = 0;
  } else { 
    flag = 1;
  }
}

// (flag = 0) -> {close}, а про flag = 1 информации нет
if (flag) {
  close();
}
```

##### Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации
Исправить текущий анализ можно, добавив в анализ к `flag` зависимость по `x`. То есть, к правилам

```
[[assume(flag == 1)]] = JOIN(n)[(flag == 0) -> {}]
[[assume(flag == 0)]] = JOIN(n)[(flag == 1) -> {}]
[[flag = 1]] = JOIN(n)[(flag == 0) -> {}]
[[flag = 0]] = JOIN(n)[(flag == 1) -> {}]
```

добавить следующие:

```
[[if (x == 5)]] = JOIN(n)[flag = 0]
[[if (cond(x)]] = JOIN(n)[flag = 1] // Любое другое условие на x
```

Тогда анализ найдёт потенциальную ошибку:

```
if (x > 15) {
  open();
  flag = 1;
  // (!(x == 5)) -> (flag = 1) -> {open}
} else {
  close();
  if (x == 5) {
    flag = 0; // (x == 5) -> (flag = 0) -> {closed}
  } else { 
    flag = 1; // (!(x == 5)) -> (flag = 1) -> {closed}
  }
}

// (!(x == 5)) -> (flag = 1) -> {open}
// (x == 5) -> (flag = 0) -> {closed}
// (!(x == 5)) -> (flag = 1) -> {closed}
if (flag) {
  close(); // В этой точке можем корректно порепортить ошибку
}
```
